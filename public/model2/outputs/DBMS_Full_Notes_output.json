{
  "metadata": {
    "source_file": "DBMS_Full_Notes.pdf",
    "query": "If anyone wants become successful in Market, following are steps of Evolution. You can consider this a 3 years Post Graduate learning program (6 Months in Each stage). It is not necessary that everyone should reach to 6th stage. One can stop at any Stage if h"
  },
  "extracted_sections": [
    {
      "document": "DBMS_Full_Notes.pdf",
      "section_title": "DATA MANIPULATION LANGUAGE (DML) C",
      "refined_text": "1. INSERT 1. INSERT INTO table-name(col1, col2, col3) VALUES (v1, v2, v3), (val1, val2, val3); 2. UPDATE 1. UPDATE table-name SET col1 = 1, col2 = ‘abc’ WHERE id = 1; 2. Update multiple rows e.g., 1. UPDATE student SET standard = standard + 1; 3. ON UPDATE CASCADE 1. Can be added to the table while creating constraints. Suppose there is a situation where we have two tables such that primary key of one table is the foreign key for another table. if we update the primary key of the fi rst table then using the ON UPDATE CASCADE foreign key of the second table automatically get updated. 3. DELETE 1. DELETE FROM table-name WHERE id = 1; 2. DELETE FROM table-name; //all rows will be deleted. 3. DELETE CASCADE - ( to overcome DELETE constraint of Referential constraints ) 1. What would happen to child entry if parent table’s entry is deleted? 2. CREATE TABLE ORDER ( order_id int PRIMARY KEY, delivery_date DATE, c ust_id INT, FOREIGN KEY(cust_id) REFERENCES customer(id) ON DELETE CASCADE ); 3. ON DELETE NULL - ( can FK have null values? ) 1. CREATE TABLE ORDER ( order_id int PRIMARY KEY, delivery_date DATE, cust_id INT, FOREIGN KEY(cust_id) REFERENCES customer(id) ON DELETE SET NULL ); 4. REPLACE 1. Primarily used for already present tuple in a table. 2. As UPDATE, using REPLACE with the help of WHERE clause in PK, then that row will be replaced. p 3. As INSERT, if there is no duplicate data new tuple will be inserted. 4. REPLACE INTO student (id, class) VALUES(4, 3); 5.",
      "importance_rank": 1,
      "page_number": 17
    },
    {
      "document": "DBMS_Full_Notes.pdf",
      "section_title": "1. Recovery Mechanism Component of DBMS supports atomicity and durability.",
      "refined_text": "2. Shadow-copy scheme 1. Based on making copies of DB (aka, shadow copies) . 2. Assumption only one Transaction (T) is active at a time. 3. A pointer called db-pointer is maintained on the disk ; which at any instant points to current copy of DB. 4. T, that wants to update DB fi rst creates a complete copy of DB. 5. All further updates are done on new DB copy leaving the original copy (shadow copy) untouched. 6. If at any point the T has to be aborted the system deletes the new copy. And the old copy is not a ff ected. 7. If T success, it is commi tt ed as, 1. OS makes sure all the pages of the new copy of DB wri tt en on the disk. 2. DB system updates the db-pointer to point to the new copy of DB.",
      "importance_rank": 2,
      "page_number": 25
    }
  ]
}